library(tidyverse)
library(dplyr)
library(stringr)
library(png)
library(MPRAnalyze)
library(BiocParallel)
PATH_TO_STARCODE = "./star_code/"
PATH_TO_STATS = "./run_stats/"
wd = getwd()

#Select the top N barcodes by DNA
N <<-100

#For checking if the spike-ins are Valid
check_valid_nucleotide <- function(string){
  valid_nuc = c("A", "a", "T", "t", "G", "g", "C", "c")
  for (i in strsplit(string, "")[[1]]){
    if (!(i %in% valid_nuc)){
      return(FALSE)
    }
  }
  return(TRUE)
}

#For analyzing the clusters generated by Starcode
#Read in the analyzed starcode data
#Give each cluster a type from addType function
#Type 1 = centroid is in map & no clustered barcodes in map
#Type 1.2 = centroid is in map & all clustered barcodes that are in the map belong to same architecture as the centroid
#Type 2 = centroid not in map & none of the clustered barcodes are in the map
#Type 3 = centroid is in map & one or more clustered barcode is in map (the clustered barcodes map to different architectures)
#Type 4 = centroid not in map & one or more clustered barcode is in map
#We only keep type 1 and 1.2
addType <- function(f, sampleNumber){
  f$sample_number = sampleNumber
  f$type = "NONE"
  f$type[f$centroid_in_map == TRUE & f$clustered_in_map == "NULL"] = "type1"
  f$type[f$centroid_in_map == FALSE & f$clustered_in_map == "NULL"] = "type2"
  f$type[f$centroid_in_map == TRUE & f$clustered_in_map != "NULL"] = "type3" 
  f$type[f$centroid_in_map == FALSE & f$clustered_in_map != "NULL"] = "type4"
  f$type[f$centroid_in_map == TRUE & f$clustered_in_map != "NULL" & f$architectures_match == T] = "type1.2"
  
  #If it is the spike in, keep as type1
  f$type[f$centroid %in% spike_ins] = "type1"
  
  f %>%
    mutate(
      collapse_stat = 0,
      collapse_stat = if_else(total_clustered!=1, centroid_counts/total_clustered, collapse_stat)) -> f
  return(f)
}


# Get the command-line arguments.
args = commandArgs(trailingOnly=TRUE)

#Read in meta data
mData=read_tsv(args[1])

#Read in barcode map
barcodeMap=read_csv(args[2])
barcodeMap %>% 
  mutate(architecture = paste0(motif,":", id,", ", period,", ", spacer,", ", promoter)) %>%
  select(architecture, barcode, class)-> barcodeMap

#Read in spike in File
#If one was provided, it will be a path to a file, otherwise it will be "None"
spikeFile=args[3]

#Read in dna tsv in File
#If one was provided, it will be a path to a file, otherwise it will be "None"
dnaTSV=args[4]

#Read in the number of threads
param = MulticoreParam(workers = args[5])


#For editing
####
# mData=read_tsv("../runs/yo3/metaData.tsv")
# barcodeMap=read_csv("../barcode_map_data/finalBarcodeMap.csv")
# barcodeMap %>%
#   mutate(architecture = paste0(motif,":", id,", ", period,", ", spacer,", ", promoter)) %>%
#   select(architecture, barcode, class)-> barcodeMap
# spikeFile="None"
# dnaTSV="None"
# threads=4
# param = BatchtoolsParam(workers = threads)
# files = c("../runs/yo3/star_code/analyzed_out_sample8_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample6_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample3_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample5_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample43_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample1_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample2_mapped_sc_out.tsv", "../runs/yo3/star_code/analyzed_out_sample42_mapped_sc_out.tsv")
# dnaTSV = read_tsv("../test_data/run1_dna_map.tsv", cols(.default = col_character()), col_names = T)

####


#If spike in file exists, read it and extract spike ins
spike_ins = c()
if (file.exists(spikeFile)){
  spikeInFile=read_table(spikeFile, col_names = F)
  for (i in spikeInFile$X1){
    if (nchar(i) == 24 && check_valid_nucleotide(i)) {
      spike_ins = c(spike_ins, i)
    }
  }
}

#Make a new long file for all the filtered/analyzed samples
longFile <- data.frame(matrix(ncol = 14, nrow = 0))

for (i in 1:length(args)){
  
  if (endsWith(args[i], "_mapped_sc_out.tsv") ){ #We only want to read in the starcode files
    print(args[i])
    curFile = read_tsv(args[i])
    sampleName = str_split(args[i], "_", n = Inf, simplify = FALSE)[[1]][4] #Gets the sample name ie "sample2"
    sampleNumber = substring(sampleName, 7) #Removes "sample" and just gets "2"
    print("SAMPLE NUMBER")
    print(sampleNumber)
    curFile = addType(curFile, sampleNumber)
    curFile$treatment = unique(mData[mData$sampleNumber == sampleNumber,]$treatment)
    longFile = rbind(longFile,curFile)
  }
}

# for (i in files){
#     print(i)
#     curFile = read_tsv(i)
#     sampleName = str_split(i, "_", n = Inf, simplify = FALSE)[[1]][4] #Gets the sample name ie "sample2"
#     sampleNumber = substring(sampleName, 7) #Removes "sample" and just gets "2"
#     print("SAMPLE NUMBER")
#     print(sampleNumber)
#     curFile = addType(curFile, sampleNumber)
#     curFile$treatment = unique(mData[mData$sampleNumber == sampleNumber,]$treatment)
#     longFile = rbind(longFile,curFile)
#   # }
# }

#Calculate the RPM.
longFile %>%
  group_by(sample_number) %>%
  summarise(norm = sum(total_counts) / 1000000) %>%
  right_join(longFile) %>%
  mutate(rpm = total_counts/norm)-> longFile

#Join the architectures
left_join(longFile, barcodeMap, by = c("centroid" = "barcode")) -> longFile

#Get the ratios of the filtered reads, to reads that made it through
#GGPLOT IMAGE
longFile %>%
  mutate(filtered = ifelse(type == "type1" | type == "type1.2", "Not Filtered", "Filtered")) %>%
  group_by(sample_number, filtered) %>%
  summarise(sum = sum(total_counts)) %>%
  ggplot(aes(x = sample_number, y = sum, fill = filtered)) +
  geom_bar(stat = "identity") + coord_flip() + labs( y = "Barcode Reads", x = "Sample Number") -> filtered_ratios
png(paste0(PATH_TO_STATS,"filtering_ratios.png"))
print(filtered_ratios)
dev.off()

#Get all types
#GGPLOT IMAGE
longFile %>%
  group_by(sample_number, type) %>%
  summarise(sum = sum(total_counts) )%>%
  ggplot(aes(x = sample_number, y = sum, fill = type)) +
  geom_bar(stat = "identity") + coord_flip() + labs(y = "Total Counts", x = "Sample Number") +
  labs(title = "The number of types of collapses.\n(2,3 and 4 are filtered)") -> type_ratios
png(paste0(PATH_TO_STATS,"type_ratios.png"))
print(type_ratios)
dev.off()

#Create a DF (summary stats)
#To keep track of total reads/barcodes and included reads/barcodes
full_join(
longFile %>%
  group_by(sample_number, treatment)%>%
  summarise(totalReads = sum(total_counts),
            totalBarcodes = n()),
longFile %>% 
  filter(type == "type1" | type == "type1.2") %>%
  group_by(sample_number, treatment)%>%
  summarise(includedReads = sum(total_counts),
            includedBarcodes = n()))-> summaryStats


#Keep the file that includes all the data before filtering fo
write_csv(longFile, paste0(PATH_TO_STATS,"pre_filter_data.csv"))

#Filter for clusters of type 1 and 1.2
#Type 1 = centroid is in map & no clustered barcodes in map
#Type 1.2 = centroid is in map & all clustered barcodes that are in the map belong to same architecture as the centroid
longFile %>% filter(type == "type1" | type == "type1.2") -> longFileFiltered

#Get the Total counds for each spikein
longFileFiltered %>%
  filter(centroid %in% spike_ins)%>%
  mutate(spike = centroid) %>%
  select(total_counts, sample_number, spike, treatment) %>%
  rename(spikeInCount = total_counts) -> spikeTotals

#Join all data for a summary of the run.
left_join(summaryStats, spikeTotals) %>%
  mutate(spike_percent = spikeInCount/includedReads) -> completeSummaryStats

#If spike-ins are present, create a Barbplot showing their percent of read for each sample
#GGPLOT IMAGE
if (length(spike_ins) > 0){
  completeSummaryStats %>%
    mutate(i = paste0(sample_number,", ", treatment)) %>%
    ggplot(aes(x = i, y = spike_percent, fill = spike)) +
    geom_bar(stat = "Identity", position="dodge") +
    labs(x="Sample", y = "Spike Reads / Included Reads") +
    coord_flip() -> spike_in_stats
  
  png(paste0(PATH_TO_STATS,"spike_in_stats.png"))
  print(spike_in_stats)
  dev.off()
}

write_csv(completeSummaryStats, paste0(PATH_TO_STATS,"run_summary.csv"))

# ******************************************************************************
#                             MAKE DNA AND RNA SAMPLES
# ******************************************************************************

#Get DNA samples
longFileFiltered %>% filter(treatment == "DNA") %>%
  rename(barcode = centroid,
        DNA_count = total_counts,
        DNA_rpm = rpm,
        DNA_sample_number = sample_number) %>%
  select(barcode, DNA_count, DNA_rpm, DNA_sample_number, architecture, class)-> dnaSamples

dnaSamples %>% arrange(desc(DNA_count), barcode) %>% # Also arrange by barcode for the event of ties
  group_by(architecture, DNA_sample_number) %>% 
  top_n(N, DNA_count) %>%
  mutate(barcode_n =  row_number()) %>%
  filter(barcode_n <= N) -> dnaSamples

#Get RNA samples
longFileFiltered %>% filter(treatment != "DNA") %>%
  rename(barcode = centroid,
         RNA_count = total_counts,
         RNA_rpm = rpm,
         RNA_sample_number = sample_number) %>%
  select(barcode, RNA_count, RNA_rpm, RNA_sample_number, architecture, treatment)-> rnaSamples

#DNA Counts per barcode
dnaSamples %>%
  ggplot(aes(x = DNA_count)) +
  geom_histogram(binwidth = 2)+
  labs(title = "DNA counts per barcode", x = "DNA count", y = "number of barcodes") -> dna_per_barcode

png(paste0(PATH_TO_STATS,"dna_per_barcode.png"))
print(dna_per_barcode)
dev.off()

only_1_dna = length(unique(dnaSamples$DNA_sample_number)) == 1

if (only_1_dna){ #If there is only one DNA sample do a simple join
  #Join the DNA samples to the RNA sample number and treatment
  full_join(
  rnaSamples %>% 
    select(RNA_sample_number, treatment) %>%
    unique() %>%
    mutate(DNA_sample_number = unique(dnaSamples$DNA_sample_number)),
  dnaSamples, relationship = "many-to-many") -> dna_joined

  #Get all data joined
  left_join(dna_joined, rnaSamples) %>%
    filter(!(barcode %in% spike_ins))-> ad
   
} else{ #If there is > 1 DNA sample number, we need the DNA TSV to pair the DNA and the RNA
  dnaTSV = read_tsv(dnaTSV, cols(.default = col_character()), col_names = T)
  rnaSamples %>%
    select(RNA_sample_number, treatment) %>%
    unique() %>%
    full_join(dnaTSV) -> dnaTSV

  dnaSamples %>% 
    left_join(dnaTSV,relationship = "many-to-many") -> dna_joined
  
  left_join(dna_joined, rnaSamples)  %>%
    filter(!(barcode %in% spike_ins)) -> ad
}


write_csv(ad, "MPRA_data.csv")
all_emp_res = data.frame()

for (cur_treatment in unique(ad$treatment)){
  print("Quantitative analysis for")
  print(cur_treatment)
  
  ad %>% filter(treatment == cur_treatment) -> cur_data
  
  
  #Get rna replicate numbers
  cur_data%>% ungroup() %>% 
    select(RNA_sample_number, treatment) %>% 
    unique() %>%
    group_by(treatment) %>% 
    reframe(replicate_n = row_number(), RNA_sample_number = RNA_sample_number) %>%
    right_join(cur_data) -> cur_data
  
  
  #Get the number of RNA and DNA barcodes for each architecture
  cur_data %>% 
    group_by(architecture, treatment) %>% 
    summarise("DNA_barcodes_" = n(), RNA_barcodes = sum(!is.na(RNA_count))) %>%
    pivot_wider(values_from = RNA_barcodes, names_from = treatment,  names_prefix = "RNA_barcodes_")-> architecture_summary
  names(architecture_summary)[names(architecture_summary) == "DNA_barcodes_"] <- paste0("DNA_barcodes_", cur_treatment)
  
  #Make sure that all barcode numbers will be counted as barcodes per replicate
  n_dna_name = paste0("DNA_barcodes_", cur_treatment)
  n_rna_name = paste0("RNA_barcodes_", cur_treatment)
  architecture_summary[n_dna_name] = architecture_summary[n_dna_name] / max(cur_data$replicate_n)
  architecture_summary[n_rna_name] = architecture_summary[n_rna_name] / max(cur_data$replicate_n)
  

  #Because there is only one treatment
  cur_data$treatment_n = 1

  cur_data %>% 
    select(DNA_count, architecture, barcode_n, class) %>% 
    unique() %>%
    pivot_wider(id_cols = c("architecture", "class"), 
                values_from = c("DNA_count"), 
                names_from = c("barcode_n"),
                names_sep = ":")-> dna_mat 
  
  cur_data %>% 
    select(RNA_count, architecture, barcode_n, replicate_n, treatment_n, class) %>%
    pivot_wider(id_cols = c("architecture", "class"), 
                values_from = c("RNA_count"), 
                names_from = c("barcode_n", "replicate_n", "treatment_n"), 
                names_sep = ":")-> rna_mat  
  
  
  #Extract control booleans
  controls = rna_mat$class == "scramble" | rna_mat$class == "spacer"
  
  #Make the rna col annotations
  cur_data %>% 
    select(barcode_n, replicate_n, treatment_n) %>% 
    unique() -> rna_col_ano
  rna_col_ano$barcode = as.factor(rna_col_ano$barcode_n)
  rna_col_ano$batch = as.factor(rna_col_ano$replicate_n)
  rna_col_ano$condition = as.factor(rna_col_ano$treatment_n)
  rna_col_ano %>% select(barcode,batch,condition) -> rna_col_ano
  
  dna_col_ano = as.data.frame(cur_data %>% select(barcode_n) %>% unique())
  dna_col_ano$barcode = as.factor(dna_col_ano$barcode_n)
  dna_col_ano %>% select(barcode) -> dna_col_ano
  
  rna_mat %>% select(-class) %>% column_to_rownames("architecture") -> ready_rna_mat
  dna_mat %>% select(-class) %>% column_to_rownames("architecture") -> ready_dna_mat
  
  ready_rna_mat[is.na(ready_rna_mat)] <- 0
  ready_dna_mat[is.na(ready_dna_mat)] <- 0
  
  
  ################################################################################
  #                              RUN MPRAnalyze
  ################################################################################
  obj <- MpraObject(dnaCounts = as.matrix(ready_dna_mat), rnaCounts = as.matrix(ready_rna_mat), 
                    dnaAnnot = as.data.frame(dna_col_ano), rnaAnnot = as.data.frame(rna_col_ano), 
                    controls = controls, 
                    BPPARAM = param)
  
  obj <- estimateDepthFactors(obj, lib.factor = c("condition", "batch"),
                              which.lib = "rna", 
                              depth.estimator = "uq")
  
  
  obj <- analyzeQuantification(obj = obj,
                               dnaDesign = ~ NULL,
                               #rnaDesign = ~ condition, 
                               BPPARAM = param)
  
  alpha <- getAlpha(obj, by.factor = "condition")
  
  #Get empircal results
  emp_res <- testEmpirical(obj = obj,statistic = alpha$`1`) #There will only be one condition at a time
  colnames(emp_res) <- paste(colnames(emp_res),cur_treatment, sep = "_")
  
  emp_res$architecture = row.names(alpha)
  
  emp_res %>%
    left_join(architecture_summary, by = "architecture") -> emp_res

  if (nrow(all_emp_res)==0){ #Nothing is in the data frame yet
    all_emp_res = emp_res
  } else{
    all_emp_res = full_join(all_emp_res, emp_res, by = "architecture")
  }
}


all_emp_res %>% 
  select(-starts_with("control")) %>%
  mutate(controls = startsWith(.$architecture, "Spacer") | startsWith(.$architecture, "Scramble")) -> all_emp_res


mData %>% 
  select(treatment, run_name, long_name, cell_type, concentration, time, cell_type, run_name) %>% 
  unique() %>%
  write_csv(paste0(unique(mData$run_name),"__meta_data.csv"))


write_csv(all_emp_res, paste0(unique(mData$run_name),"__empirical_results.csv"))

